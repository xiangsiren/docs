1. 变量： 声明 ，声明初始化，类型推断，声明多个变量，简短声明，

2. 基本类型：byte 是uint8的别名，rune 是int32的别名

   uint8 (0-255), int8(-128-127)

   bool ,数字类型, string,

3. 常量：常量可以赋值给 “合适的” 类型，而不需要类型转换

4. 函数：多返回值，命名返回值，空白符 _:用来过滤掉不需要的参数返回值

5. 数组：Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，则不会影响原始数组。

   切片不拥有数据，只是数组的引用，对切片的任何操作都会反馈在底层数组中

   当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。

6. map: 和slice类似，map也是引用类型，当map赋值给一个新变量时，他们指向同一个内部数据结构，因此改变一个变量，就会影响另一个变量

7. 字符串：字符串是不可变的，一旦被创建，不能修改；为了修改可以转化为切片

8. 结构体：命名结构体，匿名结构体，嵌套结构体

   导出结构体和字段

   如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。

9. 萨达多所

10. 函数：

    闭包：匿名函数的一个特例，当一个匿名函数访问的变量定义在函数体的外部，就称这个匿名函数为闭包。

11. 结构体取代类：

    可以说是，也可以说不是。虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。Go 中的“接口”概念提供了一种不同的方法，我们认为它易于使用，也更为普遍。Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。此外，Go 提供的特性比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。这在结构体（类）中没有受到限制。

    使用New()函数，而非构造器

12. 方法：go不是纯粹的面向对象编程语言，go不支持类，相同名字的方法可以定义在不同的类型上，而相同名字的函数是不允许的。

    指针接收器与值接收器

    指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。

    在方法中使用值接收器，在函数中使用值参数：

    当一个函数接收一个值参数，它只能接受一个值参数，

    当一个方法接受一个值接收器，它可以接受值接收器和指针接收器

13. 接口：接口定义一个对象的行为，接口指定了类型所具有的方法，并由该类型决定如何实现这些方法。

    没有包含任何方法的接口称为空接口。

    由于空接口没有方法，因此所有类型都实现了空接口。

    类型断言 (i.(T)),类型判断

    实现接口：指针接受者与值接受者

14. defer: 含有defer语句的函数，会在函数返回之前，调用另一个函数。

15. 并发：go语言原生支持并发，而不是并行语言

    并发是时间段内处理多任务，并行是同事处理多任务。

    并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信，并发情况下通信处理开销很小。多核并行系统通信开销很高，

    go使用go协程和信道处理并发

16. 协程：go协程是与其他函数和方法一起并发执行的函数和方法,go协程可以看做是轻量级线程，与线程相比，创建一个go协程的成本很小，因此在go应用中，会看到数以千计的go协程并发的运行

    协程相比于线程的优势:

    - 相比与线程，go协程的成本更低，堆栈大小只有若干kb,并且可以根据应用的需要增减，而线程必须指定固定的堆栈大小不变

    - go协程会复用数量更少的os线程，

    - go协程使用信道来进行通信，信道用于防止多个协程共享内存时

      发生竞态条件，信道可以看做go协程之间通信的管道

17. 信道：使用信道需要考虑死锁，当go协程向一个信道写入数据时，照理会有其他的go协程接受数据，如果没有的话，程序就会在运行时触发panic，形成死锁

    同理：当一个协程接受数据时，如果没有其他协程写入数据，程序也会触发panic

    单向信道：

18. 错误处理：

19. panic 和recover：

    panic:当程序发生异常时，无法继续运行，使用panic可以终止程序

    recover :内建函数，用于重新获取panic协程的控制

20. 反射：就是程序能够在运行时检查变量和值，求出他们的类型。

    在go语言中，reflect实现了运行时反射，reflect 帮助我们识别interface{}变量的底层具体类型和具体值，

21. 写入文件：

    将字符串写入文件，

22. mutex:

    临界区：当程序并发的执行时，多个go协程不应该同时访问那些修改共享资源的代码.这些修改共享资源的代码称为临界区。

    协程间的上下文切换会导致竞态条件发生。

    在任意时刻只允许一个go协程访问临界区，就可以避免竞态条件，使用mutex可以达到这个目的。

    mutex用于提供一种加锁机制，可确保某时刻只允许一个协程在临界区运行，以防止竞态条件

23. go语言特别：

    没有“对象”，没有继承多态，没有泛型

    csp并发模型，有接口，函数式编程

24. go系列教程：https://studygolang.com/subject/2

25. dsds 

26. sdsdsd

