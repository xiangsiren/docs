1. reids 数据类型：

   字符串（string）哈希（hash）列表（list）集合（sets）有序集合（sorted sets) 等类型

   

2. redis单线程快的原因：

   1. 大部分都是纯粹的内存操作
   2. 采用单线程，避免了不必要的上下文切换和竞态条件
   3. 采用单线程i/o多路复用机制，非阻塞io

3. redis好处：

   速度快，支持丰富数据类型，支持事务，丰富的特性（缓存，消息，过期自动删除）

4. Redis 相比 memcache的优势：

   可以持久化数据，支持数据的备份（既master-slave 模式的数据备份），丰富的数据类型

5. Redis 是一个开源的内存结构存储系统，可以做数据库，缓存和消息中间件

   数据库的存储模式分为硬盘数据库（内存存储索引，硬盘存储值）和内存数据库（内存存储值），Redis数据存储在内存中，读写数据的时候不受 硬盘IO速度的限制，

   实际情况，可以每个一段时间将数据集导出到磁盘（快照），

6. 为什么redis是单线程的？

   Redis 是基于内存操作，CPU不是Redis的瓶颈，Redis瓶颈可能是内存大小和网络带宽，既然单线程容易实现，那就顺理成章的选择单线程了，毕竟多线程有些麻烦。

7. 缓存雪崩：Redis缓存宕机或者失效，大量请求数据库，数据库报警挂了；

   解决办法：

   1. 事前： Redis 主从 + 哨兵, redis cluster 避免全盘崩溃
   2. 本地缓存encache + hystrix 限流降级
   3. Redis 持久化，一旦重启自动从磁盘加载数据，快速恢复缓存数据

8. 缓存穿透：大量的请求缓存查不到，数据库也查不到；这种恶意攻击的请求会把数据库直接打死，

   解决办法：

   1. 空值缓存,

   2. 采用布隆过滤器：

      布隆算法的错误率：如果数据存在可能不存在，如果数据请求不存在一定不存在

9. 缓存击穿：就是说某个key非常热点，访问非常频繁，处于集中式高并发的情况，当key缓存失效，大量请求击穿缓存，直接请求数据库，

   解决方法：

   1. 热点数据可以设置永不过期，
   2. 分布式缓存数据库，热点部署在不同的缓存服务器上避免某一点由于压力过大而down 掉

10. redis 集群的三种方式：主从复制，哨兵模式和集群

    https://www.cnblogs.com/51life/p/10233340.html

11. redis boomfilter 布隆过滤器

    布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

12. redis持久化机制：RDB(redis database) 和 AOF(Append only file)

    https://www.jianshu.com/p/425b8530ae76

    https://blog.csdn.net/weixin_30566149/article/details/99154307

    aof: 保护数据不丢失，写入性能很高

    rdb: 文件紧凑，全量备份，适合备份和灾难恢复

13. redis 内存优化：https://www.jianshu.com/p/8677603d3865

14. 缓存一致性：

    先更新数据库，再删除缓存；

    如果更新数据库成功，删除缓存失败；会造成缓存数据不一致；

    重试机制：如果删除缓存失败，捕获异常，把需要删除的key发送到消息队列，然后自建消费者，尝试再次删除key;

    异步更新缓存：

15. fdsa

16. 

17. fdsfsd

    