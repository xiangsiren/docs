### review

1. 抽象类与接口的区别：

   ​         接口是一种行为规范，是一种辐射式设计；是抽象方法的集合，一个类实现接口,必须使用类的方法,接口只是一种形式，本身不做任何事情

   ​		抽象类用来作为子类的父类，是一种模板式设计；不能被实例化，必须被继承才能使用；

   - 一个类只能继承一个抽象类，却可以实现多个接口
   - 接口中不能含有静态代码块和静态方法，抽象类中可以包含静态代码块和静态方法
   - 抽象类中的成员变量可以是多种类型的，接口中的成员变量只能是public static final 类型
   - 抽象类可以包含方法体，接口中只能存在public abstract 方法

2. 多态：同一个接口使用不同的实例，执行的操作不同

   好处：可以程序有良好的扩展，可以对类的对象通用处理

3. 并发和并行的区别：

   并行：多个事件在同一时刻发生, 并发是多个事件在同一时间间隔发生

   并行是不同实体上的多个事件，并发是一个实体上的多个事件

4. 线程与进程

   进程是程序运行和资源分配的基本单元，一个程序至少有一个进程，一个进程至少有一个线程；进程在运行过程中有独立的内存单元，而多线程共享内存资源，减少切换次数，从而效率更高；

   线程是进程的一个实体，是CPU调度和分配的基本单元，是比程序更小的能够独立运行的基本单元，同一进程的多个线程可以并发执行

5. xss攻击（css）全称（cross site script）跨站脚本攻击，如何避免

   页面被注入恶意代码，

   防范思路：对输入进行过滤，对输出编码。

6. csrf （cross site request forgey）跨站请求伪造：

   一般来说，攻击者通过伪造用户浏览器的请求

   如何避免：

   - 验证HTTP Referer字段
   - 使用验证码，但体验不太好
   - 在请求地址中添加token验证
   - 在HTTP头自定义属性并验证

7. 如何避免SQL注入：

   1. 预处理
   2. 使用正则表达式过滤传入的参数
   3. 字符串过滤

8. 死锁

   多个进程相互争夺资源僵局无法向前推进。

   产生的原因是：

   - 竞争资源（可剥夺资源，不可剥夺资源）
   - 进程间推进顺序非法

   解决基本方法：以确定的顺序获得锁，超时放弃 

9. 为什么要用多线程：

   1. 为了更好的利用cpu的资源，如果只有一个线程，则第二个任务必须等到第一个任务结束后才能进行，如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待；
   2. 进程之间不能共享数据，线程可以；
   3. 系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小

   4. Java语言内置了多线程功能支持，简化了java多线程编程。

10. java虚拟机工作原理：https://www.jianshu.com/p/c0713884fb12
    
11. 泛型：

    泛型的本质是参数化类型，也就是所操作的类型被指定我一个参数

    优点：可以让我们的数据结构放置"任何"数据类型

    不可以是基本数据类型，只能是类对象

12. == 与 equals 区别：

    　1. 对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

    　　如果作用于引用类型的变量，则比较的是所指向的对象的地址

    　2. 对于equals方法，注意：equals方法不能作用于基本数据类型的变量

    　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

    　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容

13. springboot aop 可以实现业务代码与系统级服务例如日志记录，事务及安全相关的解耦，使代码更加干净整洁

14. netty: 高性能，事件驱动，异步非阻塞的Java io 开源框架

    支持 http websoket protobuf tcp udp binary

    使用场景：高性能领域，多线程并发领域，异步通信领域

    **以下是几种常用的IO 模型**

15. BIO: 阻塞io(blocking io)，新来一个请求对应创建一个线程,线程数量过多会消耗服务器资源

16. 伪异步IO: 与BIO类似，只是将客户端-线程的模式换成了线程池，可以灵活设置线程池大小，超出线程池大小就丢进队列等候。只是对BIO 的优化，没有解决线程连接的阻塞问题

17. NIO: 非阻塞IO(non-blocking io) 同步非阻塞IO模型，利用selector 多路复用器轮询用户创建线程，只需要一个线程轮询IO事件，比较适合做高并发

18. AIO: 异步非阻塞，适合较多IO任务较长的场景，

19. java 面向对象设计原则：

    1. 单一职责原则(srp):一个类只负责一项职责，提高类的可读性和易维护性
    2. 开闭原则(ocp): 软件中的对象对扩展开放，修改关闭；我们可以用抽象构建框架，用实现扩展细节
    3. 里斯替换原则（lsp）：子类可以扩展父类的功能，但不能改变父类的原有功能
    4. 依赖倒置原则（dip）:高程模块不应该依赖低成模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖其抽象
    5. 接口隔离原则（ISP）：客户端不应该依赖它不需要的接口
    6. 迪米特原则（LOD）: 一个对象应该对其他对象保持最小的了解

20. 设计模式：最佳实践 ;三种类型(创建型，结构性，行为性)

21. 创建型：

    工厂模式：扩展性高，隐藏具体实现，调用者只关心接口即可

    单例模式：单例类只有一个实例，自己创建自己唯一的实例，并对外提供这一实例

    1. 主要解决：主要是为了解决类的频繁创建和销毁

    2. 何时使用：需要控制实例数目，节省系统资源的时候

    3. 关键代码：构造函数是私有的
    4. 饿汉式是声明私有静态变量并创建对象，懒汉式是只声明变量，在调用该类的方法时才会进行new 对象
    5. 静态式/静态内部类：

22. 结构性模式：

    装饰器模式：为已有类动态添加额外的功能，

    适配器模式：

    过滤器模式：

23. 行为性模式：

    观察者模式：

    模板模式：

    策略模式：

24. 第三方发大水

25. 地方撒地方撒

26. 撒的发生大发

27. 第三方士大夫

   



