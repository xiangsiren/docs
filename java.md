### review

1. 抽象类与接口的区别：

              1. 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
              2. 构造函数：抽象类可以有构造函数；接口不能有。
                 main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
              3. 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
                 访问修饰符：
              4. 接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

2. 多态：同一个接口使用不同的实例，执行的操作不同

   好处：可以程序有良好的扩展，可以对类的对象通用处理

3. 并发和并行的区别：

   并行：多个事件在同一时刻发生, 并发是多个事件在同一时间间隔发生

   并行是不同实体上的多个事件，并发是一个实体上的多个事件

4. 线程与进程

   进程是程序运行和资源分配的基本单元，一个程序至少有一个进程，一个进程至少有一个线程；进程在运行过程中有独立的内存单元，而多线程共享内存资源，减少切换次数，从而效率更高；

   线程是进程的一个实体，是CPU调度和分配的基本单元，是比程序更小的能够独立运行的基本单元，同一进程的多个线程可以并发执行

5. xss攻击（css）全称（cross site script）跨站脚本攻击，如何避免

   页面被注入恶意代码，

   防范思路：对输入进行过滤，对输出编码。

6. csrf （cross site request forgey）跨站请求伪造：

   一般来说，攻击者通过伪造用户浏览器的请求

   如何避免：

   - 验证HTTP Referer字段
   - 使用验证码，但体验不太好
   - 在请求地址中添加token验证
   - 在HTTP头自定义属性并验证

7. 如何避免SQL注入：

   1. 预处理
   2. 使用正则表达式过滤传入的参数
   3. 字符串过滤

8. 死锁

   多个线程相互争夺资源僵局无法向前推进。

   产生的原因是：

   - 竞争资源（可剥夺资源，不可剥夺资源）
   - 进程间推进顺序非法

   解决基本方法：以确定的顺序获得锁，超时放弃 

9. 如何防止死锁：

   1. 尽量减少同步的代码块
   2. 尽量使用juc并发类代替自己手写锁
   3. 设置超时时间，
4. 尽量降低锁的使用粒度，避免多个功能使用同一把锁
   
10. 为什么要用多线程：

   1. 为了更好的利用cpu的资源，如果只有一个线程，则第二个任务必须等到第一个任务结束后才能进行，如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待；
   2. 进程之间不能共享数据，线程可以；
   3. 系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小

   4. Java语言内置了多线程功能支持，简化了java多线程编程。

11. java虚拟机工作原理：https://www.jianshu.com/p/c0713884fb12

12. 泛型：

    泛型的本质是参数化类型，也就是所操作的类型被指定我一个参数

    优点：可以让我们的数据结构放置"任何"数据类型

    不可以是基本数据类型，只能是类对象

13. == 与 equals 区别：

    　1. 对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

    　　如果作用于引用类型的变量，则比较的是所指向的对象的地址

    　2. 对于equals方法，注意：equals方法不能作用于基本数据类型的变量

    　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

    　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容

14. 二位

15. ewewew

16. java 面向对象设计原则：

    1. 单一职责原则(srp):一个类只负责一项职责，提高类的可读性和易维护性
    2. 开闭原则(ocp): 软件中的对象对扩展开放，修改关闭；我们可以用抽象构建框架，用实现扩展细节
    3. 里斯替换原则（lsp）：子类可以扩展父类的功能，但不能改变父类的原有功能
    4. 依赖倒置原则（dip）:高程模块不应该依赖低成模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖其抽象
    5. 接口隔离原则（ISP）：客户端不应该依赖它不需要的接口
    6. 迪米特原则（LOD）: 一个对象应该对其他对象保持最小的了解

17. 设计模式：最佳实践 ;三种类型(创建型，结构性，行为性)

18. 创建型：

    工厂模式：扩展性高，隐藏具体实现，调用者只关心接口即可

    单例模式：单例类只有一个实例，自己创建自己唯一的实例，并对外提供这一实例

    1. 主要解决：主要是为了解决类的频繁创建和销毁

    2. 何时使用：需要控制实例数目，节省系统资源的时候

    3. 关键代码：构造函数是私有的
    4. 饿汉式是声明私有静态变量并创建对象，懒汉式是只声明变量，在调用该类的方法时才会进行new 对象
    5. 静态式/静态内部类：

19. 结构性模式：

    装饰器模式：为已有类动态添加额外的功能，

    适配器模式：

    过滤器模式：

20. 行为性模式：

    观察者模式：

    模板模式：

    策略模式：

21. volatile: 在Java编程中常用于保持内存可见性和防止指令重排序

22. 线程间通信：线程间通信模型有两种（共享内存和消息传递）

    1. 使用volatile 关键字
    2. 使用object类的wait() 和notify() 方法
    3. 

23. 垃圾回收机制

    什么才是垃圾,java中对象没有被其他对象引用就是无用的，此对象被称为垃圾，其占用的内存要被销毁

    判断对象为垃圾的算法：

    1. 引用计数法：引用一次计数器加一，引用失效，计数器减一 

       优点：执行效率高，

       缺点：无法检测循环引用的情况，导致内存泄漏

    2. 可达性分析算法：

       gc boot 做起点向下搜索，节点所走过的路径称为引用链，

24. https://www.jianshu.com/p/745757d373e9

25. cap定理：指的是在一个分布式系统中，一致性，可用性，分区容错性，这三个要素最多只能同时实现两个，不可能三者兼顾

    一致性： 分布式系统中，所有的备份数据，在同一时刻是否是同样的值

    可用性：一部分节点故障后，集群整体是否还能响应客户端的读写请求

    分区容错性：系统如果时限内不能达成一致，就意味着发生分区

26. ArrayList 与 linkedlist 区别：

    ArrayList 基于动态数组的数据结构，linkedlist 基于链表结构

    对于随机访问的get 和set 方法，ArrayList 优于linkedlist,因为linkedlist 要移动指针

    对于新增和删除操作，linkedlist有优势，ArrayList 需要移动数据

27. ewweew

28. spring ：开源容器框架，是一个轻量级的控制反转(IOC)和面向切片(AOP)的容器框架

29. spring aop 可以实现业务代码与系统级服务例如日志记录，事务及安全相关的解耦，使代码更加干净整洁

30. 控制反转（IOC）：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器创建和维护；有两种方式，一种DI(Dependency Injection)依赖注入，软件实体被动接受其依赖的其他组件被 IoC 容器注入；一种DL，Dependency Lookup（依赖查找）软件实体主动去某个服务注册地查找其依赖的那些服务

31. ssm:(springmvc + spring + mybatis)

32. 面向接口编程：

    结构设计中，分清层次和调用关系，每层只向外提供一组功能接口，各层间仅依赖接口而非实现类

    接口实现的变动不影响各层间的调用

    接口是用于隐藏具体实现和实现多态性的组件

33. spring 注入：是指在启动spring 容器加载bean配置的时候，完成对变量的赋值常用的两种注入方式：

    设值注入 ，构造注入

34. bean 是一个被实例化，组装，并通过spring IOC容器管理的对象，

    spring配置元数据，以下三个方法把配置元数据提供给spring容器：

    1. 基于xml的配置文件
    2. 基于注解的配置
    3. 基于Java的配置

35. 线程的生命周期：

    新建状态：new 或thread 及其子类创建线程对象

    就绪状态：线程调用start() 方法后，处于就绪队列中，等待jvm线程调度器的调度

    运行状态：获取CPU资源，就可以执行run()；他可以变为就绪，阻塞，死亡等状态

    阻塞状态：

    死亡状态：

36. java 提供三种方式创建线程：

    实现runable接口，继承thread类， 通过callable 和future

37. jar 包的作用：

    1. 用于发布和使用类库
    2. 应用程序和扩展的构建单元

38. 内存溢出和内存泄漏：

    内存溢出是指程序申请内存时没有足够的内存空间供其使用，出现out of memory

    ​		解决办法：修改jvm参数，直接增加内存

    ​							查看错误日志，对代码进行走查分析

    内存泄漏：分配出去的内存不在使用，但无法回收

39. springcloud 五大组件：

    1. 服务发现eureka: nacos代替
    2. 客户端负载均衡Ribbon:
    3. 熔断器hystrix: 保护系统，控制故障 Sentinel代替
    4. 服务网关zuul: api 网关路由 spring cloud getaway代替
    5. 分布式配置springcloud config：配置管理  nacos-config 代替

40. hash冲突的解决方法：

    1. 链地址法
    2. 再hash法

41. java里面线程池的顶级接口是Executor;真正的线程池接口是ExecutorService;**ThreadPoolExecutor** :ExecutorService的默认实现。

42. 几种常见的运行时异常：

    1. 类型转换异常
    2. 空指针异常
    3. 类找不到异常
    4. 数组越界异常
    5. 同步修改异常

43. rocketMQ:

    producer group:生产者集合，一般用于发送一类消息；

    consumer group: 消费者集合，一般用于接受一类消息进行消费

    broker：MQ消息服务(中转角色，用于消息存储与生产消费转发)

    topic: 消息主题，一级消息类型，通过topic对消息进行分类

    tag: 消息标签，二级消息类型，进一步区分某个topic下面的消息分类

    死信对列：用于处理无法被正常消费的消息

44. 奥术大师发到

45. 是的发顺丰的

46. 撒的发生发的

47. 阿士大夫

48. 手动阀

49. 似懂非懂方式

50. 撒旦法

51. 阿士大夫   



