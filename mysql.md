1. 事务：

   MySQL 事务主要用于处理操作量大，复杂度高的数据。

   事务处可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行

   事务满足的4个条件（ACID）:

   原子性（atomicity）：一个事务的所有操作，要么全部执行，要么回滚（rollback）全部失败

   一致性（consistency）：事务开始之前与结束之后，数据库的完整性没有被破坏

   隔离性（isolation）：数据库允许多个并发事务对数据读写的能力，隔离性防止多个并发事务交叉执行时而导致的数据不一致

   持久性（durability）：事务结束后，对数据的修改是持久的。

2. mysql 数据库优化

   字段

   - 尽量使用TIMESTAMP而非DATETIME；
   - 单表不要太多字段，建议20以内
   - 用整形存IP
   - 避免使用null字段，很难查询优化且占用额外索引空间

   SQL语句优化

   - 尽量避免在where 字距中使用 ！= 或 <> 操作符，否则引擎将放弃使用索引而全表扫描
   - in 和 not in 慎用，否则会导致全表扫描
   - 尽量使用varchar 代替char 
   - 向数据库中添加多条记录，拼接成一条SQL语句最快
   - 不用函数和触发器，在应用程序实现

   索引优化（主键索引，唯一索引，普通索引，全文索引，组合索引）

   - 选择合适的列建立索引
   - 建立索引的列不能为null
   - 更新频繁的字段不易建立索引
   - name列可以创建普通索引
   - 字符字段最好不要做主键

   数据库表结构优化

   - 选择合适的数据类型
   - 数据库表的范式化优化
   - 数据库表的反范式优化
   - 数据库表的水平拆分
   - 数据库表的垂直拆分

   系统配置优化

   服务器硬件优化

3. mysql 大表优化 https://www.sohu.com/a/227865372_505827

4. 大数据量分页：利用覆盖索引加速分页查询

5. MySQL 分库分表：

   业务分库：按业务将不同表放进不同库。每个库可以放在不同数据库服务器上

6. ### MySQL事务隔离级别

   SQL标准定义了4种隔离级别，高级别的隔离级别事务安全，并发性能较低，占用资源较多，低级别反之。

   - READ UNCOMMITTED(读未提交内容)
   - READ COMMITTED(读已提交内容)
   - REPEATABLE READ(可重复读)
   - SERIALIZABLE(串行化)

7. https://www.runoob.com/mysql/mysql-join.html

8. **脏读：**在隔离级别读未提交中可能会出现，一个事务读取另外一个事务还没有提交的数据叫脏读，事物A读取了事物B更新的事物，事物B没有commit并且回滚，此时就事物A产生脏读，应用也没保证数据的正确性。

9. MySQL默认的事务隔离级别是：可重复读https://www.cnblogs.com/shoshana-kong/p/10516404.html

10. https://blog.csdn.net/a281246240/article/details/86507118

11. 索引是一种高效获取数据的存储结构，MySQL索引数据结构采用b+tree

12. https://www.cnblogs.com/wlwl/p/9465583.html

13. 如何实现分布式锁?![image-20200516082047407](https://home08.oss-cn-hangzhou.aliyuncs.com/tmp/image-20200516082047407.png)

14. 千万大表优化

    https://www.jianshu.com/p/1bf3196ad1ac

15. mysql 使用b+树：B+树是平衡二叉树；https://baijiahao.baidu.com/s?id=1628226562020721873&wfr=spider&for=pc

    B+树特征：

    1. 有n个子树的中间节点包含n个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
    2. 所有叶子节点包含元素的信息以及指向记录的指针，且叶子节点按关键字自小到大顺序链接
    3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

    优势：

    1. 单一节点存储更多元素，减少io
    2. 所有查询都要到叶子节点，查询更稳定
    3. 叶子节点形成有序链表，方便范围查询

    一般性情况，数据库的B+树的高度一般在2~4层，这就是说找到某一键值的行记录最多需要2到4次逻辑IO，相当于0.02到0.04s

16. fsd

17. MySQL主键索引与唯一索引的区别

    主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

    主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。

    唯一性索引列允许空值，而主键列不允许为空值。

    主键列在创建时，已经默认为非空值 + 唯一索引了。

    主键可以被其他表引用为外键，而唯一索引不能。

    一个表最多只能创建一个主键，但可以创建多个唯一索引。

    主键和唯一索引都可以有多列。

    主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。

    在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度。

18. mysql：union 用于连接两个以上的select 结果组合到一个结果集

    **UNION 语句**：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）

    **UNION ALL 语句**：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）

19. 乐观锁与悲观锁：https://www.jianshu.com/p/ed896335b3b4

    https://www.imooc.com/article/278255

    悲观锁是数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制实现

    实现：关闭MySQL自动提交: set autocommit=0 ;**select...for update**是MySQL提供的实现悲观锁的方式

    乐观锁认为：数据一般不会造成冲突，所以在数据提交更新的时候才会检查数据是否

    冲突，

    实现：利用数据版本号（**version**）机制是乐观锁最常用的一种实现方式。

20. mysql覆盖索引与回表：https://www.jianshu.com/p/8991cbca3854

    Innodb 两类索引：

    - 聚集索引(clustered index)：直接定位行记录
    - 普通索引(secondary index)：叶子结点存储主键值

    回表：

    1. 先通过普通索引定位到主键值；

    2. 在通过聚集索引定位到行记录；

    覆盖索引：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快

    **如何实现索引覆盖**：建立联合索引，将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。

    **哪些场景可以利用索引覆盖来优化SQL**：

    1. **场景1：全表count查询优化**
    2. **场景2：列查询回表优化**
    3. **场景3：分页查询**

    地方撒：

21. mysql explain: https://www.jianshu.com/p/d81da71a3c55

    https://blog.51cto.com/12874079/2149371?source=dra

22.  MySQL InnoDB 的多版本并发控制（MVCC）: https://www.imooc.com/article/details/id/31277

23. INNER JOIN 关键字在表中存在至少一个匹配时返回行。LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。

    RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。

24. LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目

25. 主键索引和普通索引的区别：

    https://www.cnblogs.com/heishuichenzhou/p/10813463.html
    主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID，查询的时候需要做一次回表查询
    一定要回表查询么？
    不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理
    阅读：
    mysql覆盖索引详解：
    https://blog.csdn.net/jh993627471/article/details/79421363

26. 撒

27. 撒